---
title: "Simulations about coining"
header-includes:
- \usepackage{placeins}
- \usepackage{fancyhdr}
- \usepackage{setspace}
- \usepackage{chngcntr}
- \onehalfspacing
- \counterwithin{figure}{section}
- \counterwithin{table}{section}
output:
  word_document:
    fig_height: 7
    fig_width: 10
  html_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
	eval = TRUE,
	echo = TRUE,
	message = FALSE,
	warning = FALSE
)
```



```{r}
library(readxl)
library(meta)
```

#The data from the article Evangelou et al. PLoS Genet. 2006 

Load the dataset dataS1.csv:

```{r, echo=FALSE}
dataS1 <- read.csv("~/_mydrive/R projects/Simulations_coining/dataS1.csv")
head(dataS1)
```

Note that the average standard errors are average smaller in the case-control studies 

```{r, echo=FALSE}
summary(dataS1$selogORU)
summary(dataS1$selogORF)
```

# Simulations of meta-analysis 'true' treatment effects: Bias in the underlying true RORs

We first run simulations targeting the true underlying effects ignoring sampling errors. 
We assume that the association between the exposure and the outcome in subgroup 1 of a meta-analysis is reflected in OR1; similarily for subgroup 2 in the same meta-analysis (OR2).

##Assuming zero subgroup ORs, no subgroup difference, same heterogeneity for each subgroup

We generate the "true" underlying ORs for the two subgroups (OR1 and OR2) for 100 000 meta-analyses. The expected means are 1 for each subgroup ans the heterogeneity SD is 0.25 (the average observed within-subgoup heterogeneity in the 92 meta-analysis).
We expect that the ROR will also be one. As simulations show below, there is no bias produced with coining.

```{r, echo=TRUE}
logOR1=rnorm(100000,log(1),0.25)
logOR2=rnorm(100000,log(1),0.25)
logRoR=logOR1-logOR2
logRoR=mean(logRoR)
cat("The ROR without coining is: ",exp(logRoR))
#coining
pooled=apply(cbind(logOR1,logOR2),1,mean)
coin=(-as.numeric(pooled<0))+(as.numeric(pooled>0))
invlogOR1=logOR1*coin
invlogOR2=logOR2*coin
logRoRcoin=mean(invlogOR1-invlogOR2)
cat("\n The ROR after coining is: ",exp(logRoRcoin))
```

##Assuming zero subgroup ORs, no subgroup difference, different heterogeneities per subgroup
Let us now assume that the heterogeneity is not the same in each subgroup; SD heterogeneity is 0.25 in one group and 0.50 in the family-based studies.  Then bias is introduced and the mean ROR with coining is 0.77 instead of 1. 

```{r, echo=TRUE}
logOR1=rnorm(100000,log(1),0.25)
logOR2=rnorm(100000,log(1),0.50)
logRoR=logOR1-logOR2
logRoR=mean(logRoR)
cat("The ROR without coining is: ",exp(logRoR))
#coining
pooled=apply(cbind(logOR1,logOR2),1,mean)
coin=(-as.numeric(pooled<0))+(as.numeric(pooled>0))
invlogOR1=logOR1*coin
invlogOR2=logOR2*coin
logRoRcoin=mean(invlogOR1-invlogOR2)
cat("\n The ROR after coining is: ",exp(logRoRcoin))
```
 
## Assuming subgroup differences and same heterogeneity for each subgroup

Let us now assume the most likeliy scenario: that the heterogeneity is different in each subgroup and the ORs in each subgroup are different so that the exposure relates to the outcome and the expected ROR is not 1. We assume OR1=1.8 and OR2=1.2 so that the expected ROR is  1.5. Then "coining" gives a ROR = 1.26. 

```{r, echo=TRUE}
logOR1=rnorm(100000,log(1.8),0.25)
logOR2=rnorm(100000,log(1.2),0.50)
logRoR=logOR1-logOR2
logRoR=mean(logRoR)
cat("The ROR without coining is: ",exp(logRoR))
#coining
pooled=apply(cbind(logOR1,logOR2),1,mean)
coin=(-as.numeric(pooled<0))+(as.numeric(pooled>0))
invlogOR1=logOR1*coin
invlogOR2=logOR2*coin
logRoRcoin=mean(invlogOR1-invlogOR2)
cat("\n The ROR after coining is: ",exp(logRoRcoin))
```
 
 
# Simulations of study data: bias in the estimated ROR 

We run the same simulations as above, but now 10 000 are generated and we attach random-error uncertainty (bias re-sampling from the 92 standard errors for the family-based and case-control studies). 

##Assuming zero subgroup ORs, no subgroup difference, same heterogeneity for each subgroup

We generate the "true" underlying ORs for the two subgroups (OR1 and OR2) for 10 000 meta-analyses. The expected means are 1 for each subgroup ans the heterogeneity SD is 0.20.
We expect that the ROR will also be one. As simulations show below, coining produces bias because the average SEs in one subgroup (taken from the family-based studies) is on average larger than the average SEs in the case-control studies. 

```{r, echo=TRUE, message=FALSE, warning=FALSE}
library(meta)
logOR1=rnorm(10000,log(1),0.25)
logOR2=rnorm(10000,log(1),0.25)
#generate SEs
selogOR1=sample(dataS1$selogORU,10000,replace=T)
selogOR2=sample(dataS1$selogORF,10000,replace=T)
pooled=metagen(TE=c(logOR1,logOR2),seTE=c(selogOR1,selogOR2),byvar=c(1:10000,1:10000),comb.random=F)$TE.fixed.w
#coining
coin=(-as.numeric(pooled<0))+(as.numeric(pooled>0))
invlogOR1=logOR1*coin
invlogOR2=logOR2*coin

#without coining
logRoR=logOR1-logOR2
selogRoR=sqrt(selogOR1^2+selogOR2^2)
pooledlogRoR=metagen(logRoR,selogRoR)$TE.random

#the coined 
logRoRcoin=invlogOR1-invlogOR2
selogRoR=sqrt(selogOR1^2+selogOR2^2)
pooledlogRoRcoin=metagen(logRoRcoin,selogRoR)$TE.random

cat("The ROR without coining is: ",exp(pooledlogRoR))
cat("\n The ROR after coining is: ",exp(pooledlogRoRcoin))
```

##Assuming zero subgroup ORs, no subgroup difference, different heterogeneities per subgroup
Let us now assume that the heterogeneity is not the same in each subgroup; SD heterogeneity is 0.20 in the case-control studies and 0.4 in the family-based studies.  Then bias is introduced and the mean ROR with coining is 0.84 instead of 1. 

```{r, echo=TRUE}
logOR1=rnorm(10000,log(1),0.25)
logOR2=rnorm(10000,log(1),0.50)
#generate SEs
selogOR1=sample(dataS1$selogORU,10000,replace=T)
selogOR2=sample(dataS1$selogORF,10000,replace=T)
#pool subgroups
pooled=metagen(TE=c(logOR1,logOR2),seTE=c(selogOR1,selogOR2),byvar=c(1:10000,1:10000),comb.random=F)$TE.fixed.w
#coining
coin=(-as.numeric(pooled<0))+(as.numeric(pooled>0))
invlogOR1=logOR1*coin
invlogOR2=logOR2*coin

#without coining
logRoR=logOR1-logOR2
selogRoR=sqrt(selogOR1^2+selogOR2^2)
pooledlogRoR=metagen(logRoR,selogRoR)$TE.random

#the coined 
logRoRcoin=invlogOR1-invlogOR2
selogRoR=sqrt(selogOR1^2+selogOR2^2)
pooledlogRoRcoin=metagen(logRoRcoin,selogRoR)$TE.random

cat("The ROR without coining is: ",exp(pooledlogRoR))
cat("\n The ROR after coining is: ",exp(pooledlogRoRcoin))
```
 
## Assuming subgroup differences and same heterogeneity for each subgroup

Let us now assume that the heterogeneity is the same in each subgroup but the ORs in each subgroup are different so that the exposure relates to the outcome and the expected ROR is not 1. We assume OR1=2 and OR2=1.2 so that the expected ROR is  1.65. Then "coining" gives a ROR = 1.45. 

```{r, echo=TRUE}
logOR1=rnorm(10000,log(2),0.25)
logOR2=rnorm(10000,log(1.2),0.50)
#generate SEs
selogOR1=sample(dataS1$selogORU,10000,replace=T)
selogOR2=sample(dataS1$selogORF,10000,replace=T)
#pool subgroups
pooled=metagen(TE=c(logOR1,logOR2),seTE=c(selogOR1,selogOR2),byvar=c(1:10000,1:10000),comb.random=F)$TE.fixed.w
#coining
coin=(-as.numeric(pooled<0))+(as.numeric(pooled>0))
invlogOR1=logOR1*coin
invlogOR2=logOR2*coin

#without coining
logRoR=logOR1-logOR2
selogRoR=sqrt(selogOR1^2+selogOR2^2)
pooledlogRoR=metagen(logRoR,selogRoR)$TE.random

#the coined 
logRoRcoin=invlogOR1-invlogOR2
selogRoR=sqrt(selogOR1^2+selogOR2^2)
pooledlogRoRcoin=metagen(logRoRcoin,selogRoR)$TE.random

cat("The ROR without coining is: ",exp(pooledlogRoR))
cat("\n The ROR after coining is: ",exp(pooledlogRoRcoin))
```
 
# Dependance of bias on the heterogeneity and the true ROR

The following simulations graph summarizes the association between the heterogeneity in logROR (assumed to be ROR=1) and the bias produced by coining. To save running time only 1000 meta-analyses where assumed per heterogeneity 

```{r}
##Zero effects, no subgroup difference and differces in heteroeneity
ZeroEffHet=c()
for(i in c(0:10)){
logRORtrue=rnorm(1000,log(1),0.001+i*0.04)
logOR1=rnorm(1000,log(1),sqrt(0.0625))
logOR2=logOR1-logRORtrue
#generate SEs
selogOR1=sample(dataS1$selogORU,1000,replace=T)
selogOR2=sample(dataS1$selogORF,1000,replace=T)
#pool subgroups
pooled=metagen(TE=c(logOR1,logOR2),seTE=c(selogOR1,selogOR2),byvar=c(1:1000,1:1000),comb.random=F)$TE.fixed.w
#coining
coin=(-as.numeric(pooled<0))+(as.numeric(pooled>0))
invlogOR1=logOR1*coin
invlogOR2=logOR2*coin

#no coining
logRoR=logOR1-logOR2
selogRoR=sqrt(selogOR1^2+selogOR2^2)
pooledlogRoR=metagen(logRoR,selogRoR)$TE.random

#the coined 
logRoRcoin=invlogOR1-invlogOR2
selogRoR=sqrt(selogOR1^2+selogOR2^2)
pooledlogRoRcoin=metagen(logRoRcoin,selogRoR)$TE.random
ZeroEffHet=rbind.data.frame(ZeroEffHet,c(exp(pooledlogRoRcoin),exp(pooledlogRoR), 0.001+i*0.04))
}
names(ZeroEffHet)=c("RoRcoin","RoRnocoin","heterlogROR")

```


```{r}
with(ZeroEffHet,plot(heterlogROR,RoRcoin,lty=3, main="Figure 1: ROR using coining as a function of the heterogeneity of the true logROR",sub="OR1=ROR=1", xlab="Heterogeneity SD of logROR",ylab="RoR with coining"))
with(ZeroEffHet,lines(heterlogROR,RoRcoin))
abline(h=1,lty=3)
```


The followign graph summarizes the association between the underlying true ROR and the bias produced by coining. The presented line is the diagonal. We assumed that the two subgroup logOR have different heterogeneities (standard deviations 0.25 and 0.26 equal to those observed in the data by Evangelou et al. )

 
 
 
 
```{r}
subdiffdiffobshet=c()
for(i in -5:5){

logOR1=rnorm(1000,log(1.2),0.25)
logOR2=rnorm(1000,log(1.2+i*0.1),0.26)
#generate SEs
selogOR1=sample(dataS1$selogORU,1000,replace=T)
selogOR2=sample(dataS1$selogORF,1000,replace=T)
#pool subgroups
pooled=metagen(TE=c(logOR1,logOR2),seTE=c(selogOR1,selogOR2),byvar=c(1:1000,1:1000),comb.random=F)$TE.fixed.w
#coining
coin=(-as.numeric(pooled<0))+(as.numeric(pooled>0))
invlogOR1=logOR1*coin
invlogOR2=logOR2*coin

#without coining
logRoR=logOR1-logOR2
selogRoR=sqrt(selogOR1^2+selogOR2^2)
pooledRoR=metagen(logRoR,selogRoR)$TE.random
exp(pooledRoR)
#the coinedsqrt(0.06)
logRoRcoin=invlogOR1-invlogOR2
selogRoR=sqrt(selogOR1^2+selogOR2^2)
pooledRoRcoin=metagen(logRoRcoin,selogRoR)$TE.random
subdiffdiffobshet=rbind.data.frame(subdiffdiffobshet,c(exp(pooledRoRcoin),c(exp(pooledRoR)), 1.2/(1.2+i*0.1)))
}
names(subdiffdiffobshet)=c("RoRcoin", "RoRnocoin","ExpectedRoR")
```


```{r}
with(subdiffdiffobshet,plot(ExpectedRoR,ExpectedRoR, type="n"))
with(subdiffdiffobshet,plot(ExpectedRoR,RoRcoin, main="Figure 2: ROR using coining as a function of the true ROR", sub="OR1=1.2, tau1=0.25,tau2=0.26", ylab="ROR with coining",xlab="true ROR"))
abline(0,1)
```

